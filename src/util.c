/*
 * util.c - Utility functions
 */

#include "../include/converter.h"
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <stdio.h>
#include <ctype.h>

/* Endianness conversion */
uint16_t swap16(uint16_t val) {
    return ((val & 0xFF) << 8) | ((val >> 8) & 0xFF);
}

uint32_t swap32(uint32_t val) {
    return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) |
           ((val & 0xFF0000) >> 8) | ((val >> 24) & 0xFF);
}

/* Check if file exists */
int file_exists(const char *filename) {
    struct stat st;
    return stat(filename, &st) == 0;
}

/* Get auto-incremented filename if file exists */
const char *get_auto_increment_filename(const char *base_path) {
    static char result[512];
    char base[512];
    char ext[32];
    const char *dot;
    int counter = 2;

    if (!file_exists(base_path)) {
        return base_path;
    }

    /* Split into base and extension */
    dot = strrchr(base_path, '.');
    if (dot) {
        size_t base_len = dot - base_path;
        strncpy(base, base_path, base_len);
        base[base_len] = '\0';
        strcpy(ext, dot);
    } else {
        strcpy(base, base_path);
        ext[0] = '\0';
    }

    /* Find available filename */
    do {
        snprintf(result, sizeof(result), "%s%d%s", base, counter, ext);
        counter++;
    } while (file_exists(result));

    printf("File '%s' exists. Saved as '%s'.\n", base_path, result);
    return result;
}

/* Get device memory limit */
uint32_t get_device_memory_limit(const char *device_name) {
    if (strcasecmp(device_name, "Rio") == 0) {
        return DEVICE_MEM_RIO;
    } else if (strcasecmp(device_name, "Maui") == 0) {
        return DEVICE_MEM_MAUI;
    } else if (strcasecmp(device_name, "Tropez") == 0) {
        return DEVICE_MEM_TROPEZ;
    } else if (strcasecmp(device_name, "Tropez Plus") == 0 ||
               strcasecmp(device_name, "TropezPlus") == 0 ||
               strcasecmp(device_name, "TBS-2001") == 0) {
        return DEVICE_MEM_TROPEZPLUS;
    }
    return DEVICE_MEM_MAUI; /* Default */
}

/* Validate device name */
int is_valid_device_name(const char *name) {
    return (strcasecmp(name, "Rio") == 0 ||
            strcasecmp(name, "Maui") == 0 ||
            strcasecmp(name, "Tropez") == 0 ||
            strcasecmp(name, "Tropez Plus") == 0 ||
            strcasecmp(name, "TropezPlus") == 0 ||
            strcasecmp(name, "TBS-2001") == 0);  /* Accept all variants */
}

/* Normalize device name to proper case */
const char *normalize_device_name(const char *name) {
    static char result[32];
    if (strcasecmp(name, "rio") == 0) {
        return "Rio";
    } else if (strcasecmp(name, "maui") == 0) {
        return "Maui";
    } else if (strcasecmp(name, "tropez") == 0) {
        return "Tropez";
    } else if (strcasecmp(name, "tropezplus") == 0 ||
               strcasecmp(name, "tropez plus") == 0 ||
               strcasecmp(name, "tbs-2001") == 0) {
        return "TBS-2001";  /* Official model number (Tropez Plus) */
    }
    strncpy(result, name, sizeof(result) - 1);
    result[sizeof(result) - 1] = '\0';
    return result;
}

/* Initialize WFB bank structure */
void init_wfb_bank(struct WFBBank *bank, const char *device_name) {
    memset(bank, 0, sizeof(*bank));

    /* Initialize header */
    strncpy(bank->header.szSynthName, normalize_device_name(device_name), NAME_LENGTH - 1);
    strncpy(bank->header.szFileType, "Bank", NAME_LENGTH - 1);
    bank->header.wVersion = WF_VERSION;
    bank->header.bEmbeddedSamples = 1; /* Always embed samples */

    /* Set comment */
    snprintf(bank->header.szComment, MAX_COMMENT,
             "Generated by SF2WFB - SoundFont 2 to WaveFront Converter");
}

/* Copy and truncate string */
void safe_string_copy(char *dest, const char *src, size_t dest_size) {
    if (!src) {
        dest[0] = '\0';
        return;
    }
    strncpy(dest, src, dest_size - 1);
    dest[dest_size - 1] = '\0';
}
